#include <eigen3/Eigen/Core>
#include <eigen3/Eigen/LU>
#include <iostream>
#include <mc_rbdyn/Robots.h>

#pragma once

namespace msc_stabilizer{

using Eigen::Matrix;
using Eigen::Vector3d;
using Eigen::VectorXd;
using Eigen::MatrixXd;
using Eigen::Matrix3d;

struct Stabilizer {

protected:

    // Defining a 36-element vector, to represent different error vectors

    typedef Matrix <double,36,1> error;

    // Defining a 12-element command vector

    typedef Matrix <double,12,1> command;

    // Struct to group the com variables

    struct COM{

            Vector3d pos;
            Matrix3d R;
            Vector3d vel;
            Vector3d angvel;
            
        };

    // Struct to group a contact's variables

    struct contact{

            Vector3d pos;
            Matrix3d R;
            Vector3d vel;
            Vector3d angvel;
            Vector3d fc;
            Vector3d tc;

        };

    // struct to group the reference and current state values

    struct state{

    COM CoM;

    contact rightFoot;
    contact leftFoot;

    };

    // This struct groups the current state and other variables from the feedback of the Robot. The state has variables written in the CoM/Base frames,
    // while the additional variables in the feedback struct (CoM, Rc_1 and Rc_2) are written in the world frame using the virtual robot.

    struct feedback{

    state x;
    COM CoM;
    Matrix3d Rc_1, Rc_2;
    Vector3d pc_1 , pc_d_1, oc_d_1, pc_2, pc_d_2, oc_d_2;

    };

    /*  This struct groups the accelerations generated by the stabilizer, including com/base accelerations to be used in the 
    transformations from the world to the com/Base Frame, and as CoMTasks and BaseTasks to prevent the QP from giving them
    undesired values when computing the alphaD vector. */

    struct accelerations{

    Vector3d RF_linAcc;
    Vector3d RF_angAcc;

    Vector3d LF_linAcc;
    Vector3d LF_angAcc;

    Vector3d ddcom;
    Vector3d dwb;

    };

    // This struct Contains the linearized Matrices A, B and M

    struct linearMatrix{

    Matrix<double, 36, 36> A;
    Matrix<double, 36, 12> B;

    Matrix<double, 36, 36> M;

    };

/*  This struct contains the configuration of the stabilizer. It has the weight variables for the Q, R, and W matrices, 
    the stiffness and damping of the contacts, the mass and inertia of the robot, the PD gains for the CoM and Base tasks, gains for the admittance gain,
    and some constants */

    struct configuration {

        Vector3d ex {1, 0, 0};
        Vector3d ey {0, 1, 0};
        Vector3d ez {0, 0, 1};

        Matrix3d Id;
        Matrix<double, 36, 36> Id36;
        Matrix3d Zero3_3;
        Matrix<double, 12, 6> Zero12_6;
        Matrix<double, 12, 12> Zero12_12;

        double m;
        Matrix3d I;

        Matrix<double, 36, 36> Q;
        Matrix<double, 12, 12> R;
        Matrix<double, 36, 36> W;

        Matrix<double, 36, 12> N_xu;

        Vector3d qcom_p {3e6, 3e6, 3e6}; //For rigid floor: {1e10, 1e10, 1e10}. For compliant floor: {1e6, 1e6, 1e6}
        Vector3d qcom_R {1e4, 1e4, 1e4}; //For rigid floor: {1e9, 1e9, 1e9}. For compliant floor: {3e4, 3e4, 3e4}
        Vector3d qcom_vel {3e3, 3e3, 3e3}; //For rigid floor: {3e8, 3e8, 3e8}. For compliant floor: {3e2, 3e2, 3e2}
        Vector3d qcom_angvel {1e2, 1e2, 1e2}; //For rigid floor: {3e6, 3e6, 3e6}. For compliant floor: {3e3, 3e3, 3e3}

        Vector3d qRF_p {3e7, 3e7, 3e7}; //For rigid floor: {3e11, 3e11, 3e11}. For compliant floor: {3e6, 3e6, 3e6}
        Vector3d qRF_R {3e4, 3e4, 3e4}; //For rigid floor: {3e7, 3e7, 3e7}. For compliant floor: {1e5, 1e5, 1e5}
        Vector3d qRF_vel {3e3, 3e3, 3e3}; //For rigid floor: {1e9, 1e9, 1e9}. For compliant floor: {1e5, 1e5, 1e5}
        Vector3d qRF_angvel {1e2, 1e2, 1e2}; //For rigid floor: {3e8, 3e8, 3e8}. For compliant floor: {1e4, 1e4, 1e4}

        Vector3d qLF_p {3e7, 3e7, 3e7}; //For rigid floor: {3e11, 3e11, 3e11}. For compliant floor: {3e6, 3e6, 3e6}
        Vector3d qLF_R {3e4, 3e4, 3e4}; //For rigid floor: {3e7, 3e7, 3e7}. For compliant floor: {1e5, 1e5, 1e5}
        Vector3d qLF_vel {3e3, 3e3, 3e3}; //For rigid floor: {1e9, 1e9, 1e9}. For compliant floor: {1e5, 1e5, 1e5}
        Vector3d qLF_angvel {1e2, 1e2, 1e2}; //For rigid floor: {3e8, 3e8, 3e8}. For compliant floor: {1e4, 1e4, 1e4}

        Vector3d rRF_lacc {1, 1, 1};
        Vector3d rRF_aacc {1, 1, 1};
        Vector3d rLF_lacc {1, 1, 1};
        Vector3d rLF_aacc {1, 1, 1};

        Vector3d wf_RF {0.95, 0.95, 0.95}; //For rigid floor: {0.95, 0.95, 0.95}. For compliant floor: {0.8, 0.8, 0.8}
        Vector3d wt_RF {0.95, 0.95, 0.95}; //For rigid floor: {0.95, 0.95, 0.95}. For compliant floor: {0.8, 0.8, 0.8}
        Vector3d wf_LF {0.95, 0.95, 0.95}; //For rigid floor: {0.95, 0.95, 0.95}. For compliant floor: {0.8, 0.8, 0.8}
        Vector3d wt_LF {0.95, 0.95, 0.95}; //For rigid floor: {0.95, 0.95, 0.95}. For compliant floor: {0.8, 0.8, 0.8}

        Matrix3d KFP_RF, KFP_LF;
        Matrix3d KFD_RF, KFD_LF;
        Matrix3d KTP_RF, KTP_LF;
        Matrix3d KTD_RF, KTD_LF;

        Matrix3d Rsc_RF, Rsc_LF;

        Matrix3d Kp, Kd;
        Matrix3d Kf, Kt;

        double dt = 0.005;

    };

public:

    // Constructor to set the robots, realRobots and the robotIndex of the stabilizer as the ones of the controller. However it's an empty constructor.

    Stabilizer(mc_rbdyn::Robots &robots, mc_rbdyn::Robots &realRobots, unsigned int robotIndex);

    /** This function formulates the LQR gain computation method from the linearized Matrices (Discrete, Infinite Horizon computation)
     * @brief Computes the LQR gain matrix (usually denoted K)
     * @param A State matrix of the underlying system
     * @param B Input matrix of the underlying system
     * @param Q Weight matrix penalizing the state
     * @param R Weight matrix penalizing the controls
     * @param N Weight matrix penalizing state / control pairs
     * @return K, the Generated Gain matrix (has to be a double/dynamic size matrix!)
     * @param eps Constant between iterations that determines when convergence is reached
     */

    MatrixXd lqrGain(MatrixXd A, MatrixXd B, MatrixXd Q, MatrixXd R,
                        MatrixXd N, double eps = 0.1);


    // This function computes the skew symmetric matrix of a given 3D vector

    Matrix3d S(Vector3d v);

    // This function transforms a rotation matrix to a 3d Vector
    // The transformation is based on the matrix/ axis-angle transformation

    Vector3d Mat2Ang(Matrix3d M);

    // This function sets the stabilizer's configuration defined in the struct configuration

    configuration configure (mc_rbdyn::Robots &robots);

    // This function updates the stabilizer's configuration after modifications from the GUI

    void reconfigure(configuration &config);

    // This function set the reference values 

    state reference(mc_rbdyn::Robots &robots);

    // Get the current feedback: the state needed for the stabilizer, and the variables needed to transform the
    // accelerations of the contacts from the CoM/base frame to the world frame

    feedback getFeedback(mc_rbdyn::Robots &robots, mc_rbdyn::Robots &realRobots);

    // This function computes the linearized Matrices needed for the LQR gain computation

    linearMatrix computeMatrix(state &x_ref, configuration &config);

    // This function computes the LQR gain from the linearized Matrices using the "lqrgain" function defined above 

    MatrixXd computeGain(linearMatrix &linearMatrix, configuration &config);

    // This function computes the state and force errors (scaled), and returns a trade-off between the 2 errors in a different error vector

    error computeError(state &x_ref, feedback &feedback, linearMatrix &linearMatrix, configuration &config);

    // This function generates the accelerations written in the world frame for the contact tasks

    accelerations computeAccelerations(const MatrixXd &K, feedback &feedback, state &x_ref, configuration &config, error &error);

    // Finite Differences Methods
    
    Vector3d finiteDifferences(Vector3d &vel, Vector3d &vel_old, double dt = 0.005);

    // Variables to compute and check while running the controller

    MatrixXd K_;

    state x_ref_;

    Vector3d pc_dd_1, oc_dd_1, pc_dd_2, oc_dd_2;    

    feedback feedback_;

    configuration config_;

    Matrix<double, 12, 1> f_delta_;
    error x_delta_;
    error z_delta_;
    error v_delta_;

    error error_;

    accelerations accelerations_;

    linearMatrix linearMatrix_;

    // Definition of the Modified Linear Matrices after the trade-off between the state and force errors

    Matrix<double, 36, 36> Ay;
    Matrix<double, 36, 12> By;
    Matrix<double, 36, 36> Qy;

    Matrix<double, 36, 36> N;

private:

    // Definition of sub-Matrices to simplify the expression of the Control Matrices 

    Matrix3d A31, A32, A33, A34, A41, A42, A43, A44;
    Matrix3d F1_31, F1_33, F1_41, F1_42, F1_43, F1_44;
    Matrix3d F2_31, F2_33, F2_41, F2_42, F2_43, F2_44;
    Matrix3d T1_11, T1_12, T1_13, T1_14, T1_22, T1_24;
    Matrix3d T2_11, T2_12, T2_13, T2_14, T2_22, T2_24;
    Matrix3d V1_11, V1_13, V1_22, V1_24;
    Matrix3d V2_11, V2_13, V2_22, V2_24;

    Matrix<double, 12, 12> F0, F1, F2, D1, D2, T1, T2, V1, V2;
    Matrix<double, 12, 6> G1, G2;

    // Definition of Parameters to simplify the computation's expressions (to simplify the writing of the code)

    double m;
    Matrix3d I;
    Matrix3d KFP_1;
    Matrix3d KFD_1;
    Matrix3d KTP_1;
    Matrix3d KTD_1;
    Matrix3d KFP_2;
    Matrix3d KFD_2;
    Matrix3d KTP_2;
    Matrix3d KTD_2;

    Matrix3d Rsc_1;
    Matrix3d Rsc_2;

    Vector3d com;
    Matrix3d Rb;
    Vector3d com_d;
    Vector3d o_d;

    Vector3d pc_1;
    Matrix3d Rc_1;
    Vector3d pc_d_1;
    Vector3d oc_d_1;
    Vector3d fc_1;
    Vector3d tc_1;

    Vector3d pc_2;
    Matrix3d Rc_2;
    Vector3d pc_d_2;
    Vector3d oc_d_2;
    Vector3d fc_2;
    Vector3d tc_2;

    Matrix3d Rint_1;
    Matrix3d Cb_1;
    Matrix3d Rint_2;
    Matrix3d Cb_2;

    mc_rbdyn::Robots & robots_;
    mc_rbdyn::Robots & realRobots_;

    unsigned int robotIndex_;

}; // Struct Stabilizer
} // Namespace msc_stabilizer
