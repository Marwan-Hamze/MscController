#include <eigen3/Eigen/Core>
#include <eigen3/Eigen/LU>
#include <iostream>
#include <mc_rbdyn/Robots.h>

#pragma once

namespace msc_stabilizer{

using Eigen::Matrix;
using Eigen::Vector3d;
using Eigen::VectorXd;
using Eigen::MatrixXd;
using Eigen::Matrix3d;

struct Stabilizer {

protected:

    // Defining a 48-element vector, to group the state error and force error

    typedef Matrix <double,48,1> error;

    // Defining a 18-element command vector

    typedef Matrix <double,18,1> command;

    // Struct to group the com variables

    struct COM{

            Vector3d pos;
            Matrix3d R;
            Vector3d vel;
            Vector3d angvel;
            
        };

    // Struct to group a contact's variables

    struct contact{

            Vector3d pos;
            Matrix3d R;
            Vector3d vel;
            Vector3d angvel;
            Vector3d fc;
            Vector3d tc;

        };

    // struct to group the reference and current state values

    struct state{

    COM CoM;

    contact rightFoot;
    contact leftFoot;
    contact rightHand;

    };

    // This struct groups the current state and other variables from the feedback of the Robot. The state has variables written in the CoM/Base frames,
    // while the additional variables in the feedback struct (CoM, Rc_1 and Rc_2) are written in the world frame using the virtual robot.

    struct feedback{

    state x;
    COM CoM;
    Matrix3d Rc_1, Rc_2, Rc_3;
    Vector3d pc_1 , pc_d_1, oc_d_1, pc_2, pc_d_2, oc_d_2, pc_3, pc_d_3, oc_d_3;

    };

    /*  This struct groups the accelerations generated by the stabilizer, including com/base accelerations to be used in the 
    transformations from the world to the com/Base Frame, and as CoMTasks and BaseTasks to prevent the QP from giving them
    undesired values when computing the alphaD vector. */

    struct accelerations{

    Vector3d RF_linAcc;
    Vector3d RF_angAcc;

    Vector3d LF_linAcc;
    Vector3d LF_angAcc;

    Vector3d RH_linAcc;
    Vector3d RH_angAcc;

    Vector3d ddcom;
    Vector3d dwb;

    };

    // This struct Contains the linearized Matrices A, B and M

    struct linearMatrix{

    Matrix<double, 48, 48> A;
    Matrix<double, 48, 18> B;

    Matrix<double, 48, 48> M;

    };

    struct configuration {

        Vector3d ex {1, 0, 0};
        Vector3d ey {0, 1, 0};
        Vector3d ez {0, 0, 1};

        Matrix3d Id;
        Matrix<double, 48, 48> Id48;
        Matrix3d Zero3_3;
        Matrix<double, 12, 6> Zero12_6;
        Matrix<double, 12, 12> Zero12_12;

        double m;
        Matrix3d I;

        Matrix<double, 48, 48> Q;
        Matrix<double, 18, 18> R;
        Matrix<double, 48, 48> W;

        Matrix<double, 48, 18> N_xu;

        Vector3d qcom_p {5e10, 5e10, 5e10}; 
        Vector3d qcom_R {3e10, 3e10, 3e10}; 
        Vector3d qcom_vel {3e10, 3e10, 3e10}; 
        Vector3d qcom_angvel {1e10, 1e10, 1e10}; 

        Vector3d qRF_p {1e10, 1e10, 1e10}; 
        Vector3d qRF_R {1e12, 1e12, 1e12}; 
        Vector3d qRF_vel {2e11, 2e11, 2e11}; 
        Vector3d qRF_angvel {1e12, 1e12, 1e12}; 

        Vector3d qLF_p {1e10, 1e10, 1e10};  
        Vector3d qLF_R {1e12, 1e12, 1e12}; 
        Vector3d qLF_vel {2e11, 2e11, 2e11};  
        Vector3d qLF_angvel {1e12, 1e12, 1e12}; 

        Vector3d qRH_p {3e12, 3e12, 3e12}; 
        Vector3d qRH_R {3e12, 3e12, 3e12}; 
        Vector3d qRH_vel {1e13, 1e13, 1e13}; 
        Vector3d qRH_angvel {3e12, 3e12, 3e12}; 

        Vector3d rRF_lacc {1, 1, 1};
        Vector3d rRF_aacc {1, 1, 1};
        Vector3d rLF_lacc {1, 1, 1};
        Vector3d rLF_aacc {1, 1, 1};
        Vector3d rRH_lacc {1, 1, 1};
        Vector3d rRH_aacc {1, 1, 1};

        Vector3d wf_RF {0.95, 0.95, 0.95}; 
        Vector3d wt_RF {0.95, 0.95, 0.95}; 
        Vector3d wf_LF {0.95, 0.95, 0.95}; 
        Vector3d wt_LF {0.95, 0.95, 0.95}; 
        Vector3d wf_RH {0.95, 0.95, 0.95};
        Vector3d wt_RH {0.95, 0.95, 0.95};

        Matrix3d KFP_RF, KFP_LF, KFP_RH;
        Matrix3d KFD_RF, KFD_LF, KFD_RH;
        Matrix3d KTP_RF, KTP_LF, KTP_RH;
        Matrix3d KTD_RF, KTD_LF, KTD_RH;

        Matrix3d Rsc_RF, Rsc_LF, Rsc_RH;

        Matrix3d Kp, Kd;

        double dt = 0.005;

    };

public:

    // Constructor to set the robots, realRobots and the robotIndex of the stabilizer as the ones of the controller

    Stabilizer(mc_rbdyn::Robots &robots, mc_rbdyn::Robots &realRobots, unsigned int robotIndex);

    /** This function formulates the LQR gain computation method from the linearized Matrices (Discrete, Infinite Horizon computation)
     * @brief Computes the LQR gain matrix (usually denoted K)
     * @param A State matrix of the underlying system
     * @param B Input matrix of the underlying system
     * @param Q Weight matrix penalizing the state
     * @param R Weight matrix penalizing the controls
     * @param N Weight matrix penalizing state / control pairs
     * @return K, the Generated Gain matrix (has to be a double/dynamic size matrix!)
     * @param eps Constant between iterations that determines when convergence is reached
     */

    MatrixXd lqrGain(MatrixXd A, MatrixXd B, MatrixXd Q, MatrixXd R,
                        MatrixXd N, double eps = 0.1);


    // This function computes the skew symmetric matrix of a given 3D vector

    inline Matrix3d S(Vector3d const &v);

    // This function transforms a rotation matrix to a 3d Vector
    // The transformation is based on the matrix/ axis-angle transformation

    Vector3d Mat2Ang(Matrix3d const &M);

    // This function sets the stabilizer's configuration defined in the struct configuration

    configuration configure (mc_rbdyn::Robots &robots);

    // This function updates the stabilizer's configuration after modifications from the GUI

    void reconfigure(configuration &config);

    // This function set the reference values 

    state reference(mc_rbdyn::Robots &robots);

    // Get the current feedback: the state needed for the stabilizer, and the variables needed to transform the
    // accelerations of the contacts from the base frame to the world frame

    feedback getFeedback(mc_rbdyn::Robots &robots, mc_rbdyn::Robots &realRobots);

    // This function computes the linearized Matrices needed for the LQR gain computation

    linearMatrix computeMatrix(state &x_ref, configuration &config);

    // This function computes the LQR gain from the linearized Matrices using the "lqrgain" function defined above 

    MatrixXd computeGain(linearMatrix &linearMatrix, configuration &config);

    // This function computes the state and force errors (scaled), and returns a trade-off between the 2 errors in a different error vector

    error computeError(state &x_ref, feedback &feedback, configuration &config);

    // This function generates the accelerations written in the world frame for the contact tasks

    accelerations computeAccelerations(const MatrixXd &K, feedback &feedback, state &x_ref, configuration &config, error &error);

    // Finite Differences Methods
    
    Vector3d finiteDifferences(Vector3d &vel, Vector3d &vel_old, double dt = 0.005);

    // Variables to compute and check while running the controller

    MatrixXd K_;

    state x_ref_;

    Vector3d pc_dd_1, oc_dd_1, pc_dd_2, oc_dd_2, pc_dd_3, oc_dd_3;

    feedback feedback_;

    configuration config_;

    Matrix<double, 18, 1> f_delta_;
    error x_delta_;
    error z_delta_;

    error error_;

    accelerations accelerations_;

    linearMatrix linearMatrix_;

private:

    // Definition of the Modified Linear Matrices after the trade-off between the state and force errors

    Matrix<double, 48, 48> Ay;
    Matrix<double, 48, 18> By;
    Matrix<double, 48, 48> Qy;

    Matrix<double, 48, 48> N;

    // Definition of sub-Matrices to simplify the expression of the Control Matrices 

    Matrix3d A31, A32, A33, A34, A41, A42, A43, A44;
    Matrix3d F1_31, F1_33, F1_41, F1_42, F1_43, F1_44;
    Matrix3d F2_31, F2_33, F2_41, F2_42, F2_43, F2_44;
    Matrix3d F3_31, F3_33, F3_41, F3_42, F3_43, F3_44;
    Matrix3d T1_11, T1_12, T1_13, T1_14, T1_22, T1_24;
    Matrix3d T2_11, T2_12, T2_13, T2_14, T2_22, T2_24;
    Matrix3d T3_11, T3_12, T3_13, T3_14, T3_22, T3_24;
    Matrix3d V1_11, V1_13, V1_22, V1_24;
    Matrix3d V2_11, V2_13, V2_22, V2_24;
    Matrix3d V3_11, V3_13, V3_22, V3_24;

    Matrix<double, 12, 12> F0, F1, F2, F3, D1, D2, D3, T1, T2, T3, V1, V2, V3;
    Matrix<double, 12, 6> G1, G2, G3;

    // Definition of Parameters to simplify the computation's expressions

    double m;
    Matrix3d I;
    Matrix3d KFP_1;
    Matrix3d KFD_1;
    Matrix3d KTP_1;
    Matrix3d KTD_1;
    Matrix3d KFP_2;
    Matrix3d KFD_2;
    Matrix3d KTP_2;
    Matrix3d KTD_2;
    Matrix3d KFP_3;
    Matrix3d KFD_3;
    Matrix3d KTP_3;
    Matrix3d KTD_3;

    Matrix3d Rsc_1;
    Matrix3d Rsc_2;
    Matrix3d Rsc_3;

    Vector3d com;
    Matrix3d Rb;
    Vector3d com_d;
    Vector3d o_d;

    Vector3d pc_1;
    Matrix3d Rc_1;
    Vector3d pc_d_1;
    Vector3d oc_d_1;
    Vector3d fc_1;
    Vector3d tc_1;

    Vector3d pc_2;
    Matrix3d Rc_2;
    Vector3d pc_d_2;
    Vector3d oc_d_2;
    Vector3d fc_2;
    Vector3d tc_2;

    Vector3d pc_3;
    Matrix3d Rc_3;
    Vector3d pc_d_3;
    Vector3d oc_d_3;
    Vector3d fc_3;
    Vector3d tc_3;

    Matrix3d Rint_1;
    Matrix3d Cb_1;
    Matrix3d Rint_2;
    Matrix3d Cb_2;
    Matrix3d Rint_3;
    Matrix3d Cb_3;

    mc_rbdyn::Robots & robots_;
    mc_rbdyn::Robots & realRobots_;

    unsigned int robotIndex_;

}; // Struct Stabilizer
} // Namespace msc_stabilizer